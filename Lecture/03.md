# Knowledge Representation & Reasoning : Logic

## 지식의 활용

-   알고 있는 지식을 정리
-   프로그램에 삽입
-   프로그램에 질문
-   프로그램에서 축적된 지식을 추론하여 답을 제시

### 지식의 축적과 추론을 위한 Logic의 활용

-   인간의 Symbolic Knowledge를 유연하게 표현하거나 처리 가능
-   Representation in Logic
-   질의에 사용 될 수 있는 관계를 정의 (represent or define)
-   질의를 Logic으로 표현
-   Knowledge Base에서 해답 추론 = 주어진 KB에서 질의가 TRUE 인지 check
-   Logic을 사용하여 상징적 지식을 유연하게 처리 가능
    -   Steps solving problems with logic
        1. 주어진 사실(Fact)들을 Logic으로 표현
        2. 필요한 정의나 규칙을 Logic으로 표현
        3. 질의(Queries)를 Logic으로 표현
        -   `Usually given by experts`
        4. 질의 (queries)가 TRUE 또는 FALSE인지 check
        -   `Usually done by systems (there is a general algorithm for this)`
    -   새로운 사실 (Facts), 정의 (definitions), 질의 (Queries)가 추가될 경우
        -   1, 2, or 3의 과정을 반복하며 Logic statements를 추가 또는 변경

### Knowledge Based System

-   Prolog, CLIPS, JESS, Expert System Shell 등의 지식 처리 관련 SW마다 고유의 지식 표현 scheme과 추론 알고리즘을 구현하고 있으나 기본적으로 Logic을 사용

## Propositional Logic (명제 논리)

-   Proposition (명제): TRUE or FALSE를 판별할 수 있는 문장

    -   주의 깊게 읽어 보시오 X 판별 불가능
    -   물은 상온에서 액체이다 ~~ 애매함
    -   1 + 1 = 3 O 판별 가능

-   단위 명제 (Proposition constant)와 복합명제 (Compound Sentence)
-   단위 명제:
    -   p: 철수는 사람이다
    -   q: 사람은 언젠가 죽는다
-   복합명제: $\neg p, p\lor q, p\land q, p\rightarrow q, p\leftrightarrow q$ (단위명제와 Connectivities(연결사)로 구성)

### Connectivities

| Connectivities | 이름               | 의미                 |
| -------------- | ------------------ | -------------------- |
| $\lor$         | Disjunction 논리합 | OR                   |
| $\land$        | Conjuction 논리곱  | And                  |
| $\neg$         | Negation 부정      | Not                  |
| $\rightarrow$     | Implication 함의   | Implies (if...then)  |
| $\leftrightarrow$         | Equivalence 동치   | if and only if (iff) |

### 명제의 해석 (Interpretation)

-   진위표 (Truth table)를 사용하여 명확히 해석 가능

| $\alpha$ | $\beta$ | $\neg\alpha$ | $\alpha\lor\beta$ | $\alpha\land\beta$ | $\alpha\rightarrow\beta$ | $\alpha\leftrightarrow\beta$ | $\alpha\oplus\beta$ |
| -------- | ------- | ------------ | ----------------- | ------------------ | --------------------- | ----------------- | ------------------- |
| F        | F       | T            | F                 | F                  | T                     | T                 | F                   |
| F        | T       | T            | T                 | F                  | T                     | F                 | T                   |
| T        | F       | F            | T                 | F                  | F                     | F                 | T                   |
| T        | T       | F            | T                 | T                  | T                     | T                 | F                   |

-   n 개의 명제가 있다면 $2^n$개의 해석 가능

### Literal

-   명제 기호 p와 명제 기호 p의 부정 $\neg$ p

### Clause (논리 절)

-   리터럴들이 논리합으로만 연결되거나 논리곱으로 연결된 논리식
    $$ P \lor Q \lor \neg R(논리합 절)$$
$$ P \land Q \land \neg R (논리곱 절)$$

### 논리곱 정규형 (Conjunctive Normal Form, CNF)

-   논리합 절들이 논리곱으로 연결되어 있는 논리식
    $$(P \lor Q \lor \neg R) \land (\neg Q \lor R \lor S)\land (P \lor R \lor S)$$

### 논리합 정규형 (Disjunctive Normal Form, DNF)

-   논리곱 절들이 논리합으로 연결되어 있는 논리식
    $$(P \land Q \land \neg R) \lor (\neg Q \land R \land S)\lor (P \land R \land S)$$

### Valid Logical Expression (항진식, Tautology)

-   언제나 참인 논리식
-   EX) $P \lor \neg P$
    P = T & P = F 둘다: $P \lor \neg P = T$

### Contradiction(항위식)

-   항상 거짓이 되는 논리식
-   EX) $P \land \neg P$
    P = T & P = F 둘다: $P \land \neg P = F$

### Satisfiable(충족가능한) 논리식

-   참으로 만들 수 있는 모델이 하나라도 있는 논리식
-   EX) $(P \lor \neg Q) \land (Q \lor \neg R)$
-   P = T, Q = T, R = F

### Unsatisfiable(충족불가능한) 논리식

-   참으로 만들 수 있는 모델이 전혀 없는 논리식
-   EX) $P \land \neg P$

### 논리적 동치 (Logical Equivalence)

-   De Morgan's Law
    $$\neg(\alpha \lor \beta) \equiv (\neg \alpha \land \neg \beta)$$
    $$\neg(\alpha \land \beta) \equiv (\neg \alpha \lor \neg \beta)$$

-   Implication
    $$(\alpha \rightarrow \beta) \equiv (\neg \alpha \lor \beta)$$

-   Associative Law
    $$(\alpha \lor \beta)\lor \gamma \equiv \alpha \lor (\beta \lor \gamma)$$
    $$(\alpha \land \beta)\land \gamma \equiv \alpha \land (\beta \land \gamma)$$

-   Distributive Law
    $$(\alpha \lor \beta)\land \gamma \equiv (\alpha \land \gamma ) \lor (\beta \land \gamma)$$
    $$(\alpha \land \beta)\lor \gamma \equiv (\alpha \lor \gamma ) \land (\beta \lor \gamma)$$

### 논리적 동치 관계를 이용한 논리식의 변화

-   논리식의 동치관계를 이용하면 임의의 논리식을 논리곱 정규형(CNF)과 같은 정형식으로 변환 가능

$$p \land (q \rightarrow r) \rightarrow p \land q$$
$$ \equiv \neg(p \land (\neg q \lor r)) \lor (p \land q)$$
$$\equiv (\neg p \lor \neg(\neg q \lor r)) \lor (p \land q)$$
$$\equiv (\neg p \lor (q \land \neg r)) \lor (p \land q)$$
$$\equiv ((\neg p \lor q) \land(\neg p \lor \neg r)) \lor (p \land q)$$
$$\equiv ((\neg p \lor q) \lor (p \land q)) \land ((\neg p \lor \neg r) \lor (p \land q))$$
$$\equiv(((\neg p \lor q) \lor p) \land ((\neg p \lor q)\lor q)) \land (((\neg p \lor \neg r) \lor p)\land((\neg p \lor \neg r)\lor q))$$
$$\equiv (T \lor q) \land (\neg p \lor q) \land (T\lor \neg r) \land (\neg p \lor \neg r \lor q)$$
$$\equiv (\neg p \lor q) \land (\neg p \lor \neg r \lor q)$$


### Logical Entailment (논리적 귀결)

-   논리식의 집합 $\Delta$의 모든 정형식을 참으로 만드는 모델이 어떤 논리식 $\omega$를 참으로 만든다면
    -   $\Delta$는 $\omega$를 논리적으로 귀결한다 (logically entail)
    -   $\omega$는 $\Delta$를 논리적으로 따른다 (logically follow)
    -   $\omega$는 $\Delta$의 논리적 결론이다 (logical consequence)

### 명제의 추론 (inference)

-   참인 명제들로부터 새로운 참의 명제를 추론

### 추론 규칙 (inference rules)

-   Modus Ponens (긍정 논법): 명제 p 와 $p\rightarrow q$가 참이면 q는 참

$$p\rightarrow q: 새이다 \rightarrow 날 수 있다$$
$$p: 새이다$$
$$q: 날 수 있다$$
$$p \rightarrow q, p \vdash q $$

-   Modus Tollens (부정 논법) : 명제 $p\rightarrow q$ 와 $\neg q$가 참이면 $\neg p$는 참

$$p\rightarrow q: 새이다 \rightarrow 날 수 있다$$
$$q: 날 수 없다$$
$$p: 새가 아니다$$
$$p \rightarrow q, \neg q \vdash \neg p $$

-   Syllogism (삼단 논법): 명제 $p\rightarrow q$ 와 $q\rightarrow r$이 참이면 $p\rightarrow r$이 참

$$p\rightarrow q: 새이다 \rightarrow 날개가 있다$$
$$q\rightarrow r: 날개가 있다 \rightarrow 날 수 있다$$
$$p\rightarrow r: 새이다 \rightarrow 날 수 있다$$

$$ p \rightarrow q, q \rightarrow r \vdash p \rightarrow r$$

-   Resolution (논리 융합): 두개의 논리합절이 같은 기호의 긍정과 부정의 리터럴을 서로 포함하고 있을 때 해당 리터럴들을 제외한 나머지 리터럴들의 논리합절을 만들어냄

$$P \lor q, \neg P \lor r \vdash q \lor r$$

$$ q \lor r: 논리융합식 (resolvent)$$

### 추론 규칙(inference rules)의 정당성(sound)과 완전성(complete)

-   추론 규칙에 의해 생성된 논리식은 주어진 논리식들이 논리적으로 귀결하는 것으로 항상 참이다(sound)

$$\Delta \vdash \omega \rightarrow \Delta \vDash \omega$$

- 주어진 논리식들이 논리적으로 귀결하는 것들은 추론 규칙이 찾아 낼 수 있다(complete). 

### Theorem proving (정리 증명)
- 질문이 주어졌을 때, 주어진 지식 (논리)을 바탕으로 추론한 답이 참이라는 것을 입증한다면 질문에 대한 답이 맞다는 것을 의미

- Axiom (공리): 추론할 때 참인 것으로 주어지는 논리식
- Theorem (정리): 공리들에 추론 규칙을 적용하여 얻어지는 논리식
- 정리 증명: 공리들을 사용하여 정리가 참인 것을 보이는 것
    - constructive proof (구성적 증명): 공리들에 추론 규칙들을 적용하여 증명을 만들어 보이는 증명
    - Resolution Refutation (논리융합 반박): 증명할 논리를 부정 (negation) 한 다음, 논리융합 방법을 적용하여 모순이 발생하는 것을 보여서 정리가 참임을 증명하는 방법

#### Resolution Refutation (논리융합 반박)
$$S \vDash \alpha, where S = \{C_1, C_2, ..., C_N\}$$

1. $\neg\alpha$를 S에 포함
2. p와 $\neg p$를 포함하는 명제 $C_i$ 와 $C_j$를 선택

$$ C_i = (p \lor \beta) \& C_j = (\neg p \lor \gamma)$$

3. $C_i$와 $C_j$의 논리융합을 통해 $(\beta\lor\gamma)$를 만들고 이를 집합 S에 추가
4. Empty Clause가 만들어질 때까지 2,3,4의 과정을 반복
$$S = \{...,\alpha, \neg\alpha\}$$

##### 예시
- 공리
$$P \lor Q$$
$$ P \rightarrow Q$$
$$ Q\rightarrow R$$

- 정리
$$R$$

- 추가 공리
$$ \neg P \lor R$$
$$ \neg Q \lor R$$
$$ R \implies \neg R$$


1. $$(P \lor Q) \lor (\neg P \lor R)$$
$$\equiv Q\lor R$$

2. $$(\neg Q \lor R) \lor \neg R$$
$$\equiv \neg Q$$


3.  $$(Q\lor R)\lor\neg Q$$
$$\equiv R$$

4. $$ R \lor \neg R$$
$$\equiv 모순$$

### 예시 문제
$$a, a\rightarrow b, b\rightarrow c\lor d, c\rightarrow e, d\rightarrow f \vDash e\lor f$$

$$\neg p\rightarrow r, p \rightarrow s, r \rightarrow q, s\rightarrow \neg t, t \vDash q$$

### 실제 적용 예시
S:
- A와B는 Room 27또는 Room 28에 있음
- A와B는 같은 방에 있지 않음
- B는 Room 27에 있음

b:A가 Room 28에 있는가?

- S $\vDash$ b?
- 문제를 충분히 표현할 수 있도록 단위 명제를 정의
    - a: A는 Room 27에 있다
    - b: A는 Room 28에 있다
    - c: B는 Room 27에 있다
    - d: B는 Room 28에 있다

- 명제로 문제와 질문을 표현
    - $(a\rightarrow\neg b) \land (\neg a\rightarrow b) \land (c\rightarrow\neg d) \land (\neg c\rightarrow d) $
    - $(a\rightarrow\neg c) \land (b \rightarrow \neg d) \land (c\rightarrow\neg a) \land (d\rightarrow \neg b) $
    - c
    - b?

- Clausal Form으로 변환
    - $(a\rightarrow\neg b) \land (\neg a\rightarrow b) \land (c\rightarrow\neg d) \land (\neg c\rightarrow d) $
    $\equiv \neg a \lor \neg b, a\lor b, \neg c \lor \neg d, c \lor d$

    - $(a\rightarrow\neg c) \land (b \rightarrow \neg d) \land (c\rightarrow\neg a) \land (d\rightarrow \neg b) $
    $\equiv \neg a \lor \neg c, \neg b\lor \neg d$
    - c
    - b?


- 논리융합 반박(Resolution Refutation)
- $\neg a \lor \neg b, a\lor b, \neg c \lor \neg d, c \lor d, \neg a \lor \neg c, \neg b\lor \neg d, c, \neg b$
- $\neg a \lor \neg c, c \equiv \neg a$
- $\neg a, a\lor b \equiv b$
- $b, \neg b \equiv 모순$
- 참!!!!!

## Predicate Logic (술어 논리)

### 그냥 PPT 보삼!!!!


## Probabilistic Knowledge Representation & Reasoning

### 불확실성을 가진 지식의 표현과 추론
- 확률: 불확실성을 모델링할 수 있는 중요한 수학적 수단으로서 많은 AI 알고리즘들이 확률 기반으로 발전
    - Naive Bayesian Model, Bayesian Network, Hidden Markov Model등
- 확률의 의미
    - 상대빈도 확률 (Relative Frequency Probability): 전체 실험 회수 대비 관심 사건의 상대적 빈도
    - 주관적 확률(Subjective Probability): 확신 또는 믿음의 정도

- Properties
    - If $A \subseteq B \subseteq U$, then
    $$0 \leq P(A)  \leq P(B) \leq 1$$
    - If $A, B \subseteq U$, then
    $$P(A,B) + P(A,\neg B) = P(A)$$
    - If $A, B \subseteq U$, then
    $$P(A or B) = P(A) + P(B) - P(A,B)$$
    - If $H_i \subseteq U$ for $1 \leq i \leq n$, $H_i \cap H_j = \empty$ whenever $i \neq j$ and $H_1 \cup H_2 \cup ... \cup H_n = U$, then
    $$P(A) = P(A, H_1) + P(A, H_2) + ... + P(A, H_n)$$

### Conditional Probability (조건부 확률)
$$ P(A|B) = \frac{P(A,B)}{P(B)}$$
- B가 일어났다는 가정하에 A가 발생할 확률, 또는 B가 Universal Set이라는 가정하에 A의 확률

- A: 두 주사위의 합이 8이다
- B: 첫 번째 주사위는 3이다

$$P(A|B) = \frac{P(A, B)}{P(B)} = \frac{1/36}{6/36} = \frac{1}{6}$$

#### Bayesian Theorem

$$P(A|B) = \frac{P(B|A)P(A)}{P(B)}$$
- P(A|B) = 사후 확률
- P(B|A) = 가능도
- P(A)  = 사전 확률
- P(B) = 증거

$$P(A|B)P(B) = P(B|A)P(A) = P(A,B)$$

- Posterior Probability: 새로운 증거가 주어졌을떄 어떤 이벤트의 확률, 어떤 정보가 주어졌을 때 어떤 이벤트가 발생할 확률

- Chain Rule
$$ P(A, B, C, D) = P(A|B, C, D)P(B|C, D)P(C|D)P(D)$$
- $P(A,B,C,D) = P(A|B,C,D)P(B,C,D)$
- $P(B,C,D) = P(B|C,D)P(C,D)$
- $P(C, D) = P(C|D)P(D)$

#### Properties of Conditional Probability
- Variations
$$P(A|B, C) = \frac{P(A,B,C)}{P(B,C)}$$
$$P(A|B, C) = \frac{P(A,B|C)}{P(B|C)}$$
$$P(A,B|C) = P(A|B, C)P(B|C)$$

- If $A \subseteq B \subseteq U$, then
$$ 0 \leq P(A|C) \leq P(B|C) \leq 1$$

- If $A, B \subseteq U$, then
$$P(A,B|C) + P(A,\neg B|C) = P(A|C) = \sum_b P(A, B|C)$$
- If $A, B \subseteq U$, then
$$P(A or B|C) = P(A|C) + P(B|C) - P(A,B|C)$$

### Conditional Independence (조건부 독립)
- C가 주어졌을 때 아래 식이 만족되면 A와 B는 조건부 독립
$$P(A,B|C) = P(A|C)P(B|C)$$
$$P(A|B, C) = P(A|C)$$
- P(A): Officer A go
- P(B): Officer B go
- P(C): Commander order go

1. Commander의 지시를 모르는 상태
$$P(A|B) > P(A)$$
2. Commander의 지시 'Go'를 알고 있는 상태
$$P(A,B|C) = P(A|C) P(B|C)$$

#### 잘못된 이해
- A와B가 독립이면, $A \cap B = \empty$?

- 다음 중 옳은 경우?
- $P(A,B) = P(A)P(B) \rightarrow P(A,B|C) = P(A|C)P(B|C)$ for any C
    - Wrong
- $P(A, B|C) = P(A|C)P(B|C)$ for given C $\rightarrow P(A,B) = P(A)P(B)$
    - wrong
    - 확률 다른 동전을 던졌을 경우

- $P(A,B|C) = P(A|C)P(B|C)$ for given C $\rightarrow P(A,B|D) = P(A|D)P(B|D)$ for any D
    - C가 조건부 독립이어도, D가 조건부 독립이 아닐 수 있다

### 확률적 추론
- Traffic(T) = {Heavy, Normal}
- Construction(C) = {True, False}
- Accident(A) = {True, False}

| T| C| A | Probability| 
| -- | -- | -- |--|
|H|T|T|0.01|
|H|T|F|0.02|
|H|F|T|0.16|
|H|F|F|0.12|
|N|T|T|0.01|
|N|T|F|0.05|
|N|F|T|0.01|
|N|F|F|0.61|

- 모든 변수에 대한 확률표를 안다면 모든 경우에 대한 확률 계산 가능
- 그러나, Table Size
    - ex, 2개의 값을 갖는 3개의 변수가 존재할 경우: 8줄
    - 3개의 값을 갖는 15개의 변수가 존재할 경우: $3^15$ = 14,348,907줄

- Table size를 줄이는 방법: 변수들의 독립 (independency) 관계 이용
    - 3개의 값을 갖는 15개의 변수가 모두 독립일 경우: 45줄

### Bayesian Network
- 지식을 확률과 전문가의 지식, 그리고 조건부 독립에 관한 가정으로 표현
>Probability(Statistics) + Expert Knowledge on Direct Cause + Some Assumption on Independency

- 독립관계보다는 사건의 직접적 원인을 파악하는 것이 상대적으로 용이

#### Example

> Check PAGE 13-17

- 원인 결과 관계에서 조건부 독립

- A->B->C: Cascade 관계
    - A와 C는 종속관계
    - 그러나 B가 알려진 경우 조건부 독립

- B->A; B->C: Common Parent
    - A와 C는 종속관계
    - 그러나 B가 알려진 경우 조건부 독립

- A->B; C->B: V-structure
    - B가 알려진 경우 종속관계
    - 모르면 독립관계

### Bayes Ball Algorithm
- Bayesian Network에서 조건부 독립 관계를 확인하는 알고리즘
    $$X_A \perp X_B | X_C$$
- $X_A$ 노드에서 볼을 굴려서 $X_B$로 어떤 볼이라도 도착하면 $X_A$와 $X_B$는 조선부 독립이 아님

### Bayesian Network 정의
- 조건부 확률의 곱으로 표현된 확률분포를 방향성, 비 사이클 그래프로 표현한 네트워크
- 네트워크 상 어떤 노드 X에서의 조건부 확률은
    $$P(X|W, parent(X)) = P(X|parent(X))$$
- X: 노드
- parent(X):노드X의 부모노드
- W: X의 부모 노드와 자식 노드를 제외한 노드